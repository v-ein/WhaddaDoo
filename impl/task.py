import datetime
from enum import Enum
import time


class TaskStatus(Enum):
    ACTIVE = "active"
    DONE = "done"
    CANCELLED = "cancelled"

class Epic:
    name = ""


_ID_BASE_TIMESTAMP = datetime.datetime(2022, 1, 1).timestamp()
_ID_DIGITS = "0123456789abcdefghijklmnopqrstuvwxyz"

class Task:

    id: str = None
    status: TaskStatus = TaskStatus.ACTIVE

    # For convenience, we store the first line of the description separately,
    # in `summary`, since that's what will be displayed in the task list. The 
    # rest of the description goes into the `desc` field.

    # TODO: do we need to annotate the type on simple types like string?
    summary: str = ""
    desc: str = ""
    comments = []
    # TODO: decide on data type here. Do we want to include time? timezone?
    deadline: datetime.date = None
    epic: Epic = None
    labels = []

    def __init__(self, *arg, **kw):
        self.gen_id()

    def gen_id(self):
        """
        Generates an ID for this task based off the current date and time.
        Since the tasks are typically created manually, timestamp-based IDs
        are going to be sufficiently unique; in case of automated procedures,
        however, we'll need to improve tis process.

        Returns the generated id (and assigns it to Task.id, too).
        """
        ts = int((time.time() - _ID_BASE_TIMESTAMP) * 100)
        return self.set_numeric_id(ts)

    def set_numeric_id(self, num_id):
        """
        Converts `num_id` to text representation (as a base-36 number) and
        assigns it to this Task object. Returns the string ID.

        As a public method, intended mostly for debugging/testing purposes
        since the tasks created by the user are supposed to have timestamp-based
        IDs, generated by the Task object internally.
        """
        # Surprisingly enough, Python (as of 3.8) doesn't have a built-in
        # to convert an integer to a base-36 string.
        # For negative `ts` (e.g. a dead battery in the system clock :) ),
        # the code below will produce a "36's complement" number, but we have to
        # restrict its length. Let's max it at 7 characters, which should be
        # sufficient to span the next 24 years. Yes, the IDs will wrap-around
        # every 24 years or so, but the chances of a clash with a 24-year-old
        # task are negligibly low.
        text_id = ""
        while (num_id != 0 or text_id == "") and len(text_id) < 7:
            text_id = _ID_DIGITS[num_id % 36] + text_id
            num_id //= 36

        self.id = text_id

        return text_id
