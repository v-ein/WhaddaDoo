# Copyright Â© 2022 Vladimir Ein. All rights reserved.
# License: http://opensource.org/licenses/MIT
# 
import datetime
from enum import Enum
import time


class TaskStatus(Enum):
    ACTIVE = "active"
    DONE = "done"
    CANCELLED = "cancelled"

    @staticmethod
    def yaml_representer(dumper, data):
        return dumper.represent_str(data.value)


class Epic:
    name = ""


class TaskComment:
    date: datetime = None
    text: str = ""

    def __init__(self, text_, date_ = None):
        self.text = text_
        self.date = date_ if date_ is not None else datetime.datetime.now()

    @staticmethod
    def yaml_representer(dumper, data):
        filtered = {
            "date": data.date,
            "text": data.text
        }
        return dumper.represent_mapping('tag:yaml.org,2002:map', filtered)


_ID_BASE_TIMESTAMP = datetime.datetime(2022, 1, 1).timestamp()
_ID_DIGITS = "0123456789abcdefghijklmnopqrstuvwxyz"

class Task:

    id: str = None
    status: TaskStatus = TaskStatus.ACTIVE

    # For convenience, we store the first line of the description separately,
    # in `summary`, since that's what will be displayed in the task list. The 
    # rest of the description goes into the `desc` field.

    # TODO: do we need to annotate the type on simple types like string?
    summary: str = ""
    desc: str = ""
    comments = None
    # TODO: decide on data type here. Do we want to include time? timezone?
    deadline: datetime.date = None
    epic: Epic = None
    labels = None

    # TODO: we need the date when the task was marked as 'done' or 'cancelled'.
    # If only to sort the tasks in the 'done' list. Maybe also creation date?

    def __init__(self, *arg, **kw):
        self.gen_id()
        self.comments = []
        self.labels = []

    def gen_id(self):
        """
        Generates an ID for this task based off the current date and time.
        Since the tasks are typically created manually, timestamp-based IDs
        are going to be sufficiently unique; in case of automated procedures,
        however, we'll need to improve tis process.

        Returns the generated id (and assigns it to Task.id, too).
        """
        ts = int((time.time() - _ID_BASE_TIMESTAMP) * 100)
        return self.set_numeric_id(ts)

    def set_numeric_id(self, num_id):
        """
        Converts `num_id` to text representation (as a base-36 number) and
        assigns it to this Task object. Returns the string ID.

        As a public method, intended mostly for debugging/testing purposes
        since the tasks created by the user are supposed to have timestamp-based
        IDs, generated by the Task object internally.
        """
        # Surprisingly enough, Python (as of 3.8) doesn't have a built-in
        # to convert an integer to a base-36 string.
        # For negative `ts` (e.g. a dead battery in the system clock :) ),
        # the code below will produce a "36's complement" number, but we have to
        # restrict its length. Let's max it at 7 characters, which should be
        # sufficient to span the next 24 years. Yes, the IDs will wrap-around
        # every 24 years or so, but the chances of a clash with a 24-year-old
        # task are negligibly low.
        text_id = ""
        while (num_id != 0 or text_id == "") and len(text_id) < 7:
            text_id = _ID_DIGITS[num_id % 36] + text_id
            num_id //= 36

        self.id = text_id

        return text_id

    def get_full_desc(self):
        return self.summary + ("\n" + self.desc if self.desc else "")

    # TODO: not sure if we really need this. A static method that returns 
    # a tuple might be more useful.
    def set_full_desc(self, desc):
        paragraphs = desc.split("\n")
        self.summary = paragraphs[0]
        self.desc = "\n".join(paragraphs[1:])


    @staticmethod
    def yaml_representer(dumper, data):
        # Note: the order of keywords *does matter*. They will be written
        # to YAML in this order.
        # TODO: add deadline and status. Date values will need to be limited
        # to one-second precision (by default they're at the microsecond level).
        # TODO: instead of adding 'None' values, ignore the keywords. Or make
        # yaml.dump ignore them. Otherwise there are lines like 'labels: null'
        # in the output file.
        filtered = {
            "status": data.status,
            "labels": data.labels if len(data.labels) > 0 
                else None,
            "epic": data.epic.name if data.epic is not None 
                else None,
            "desc": data.get_full_desc(),
            "comments": data.comments if len(data.comments) > 0 
                else None
        }
        filtered = dict((k, v) for (k, v) in filtered.items() if v is not None)
        return dumper.represent_mapping('tag:yaml.org,2002:map', filtered)

    @staticmethod
    def from_plain_object(id, obj):
        """
        Construct a task based off a plain object read from YAML.

        We can't use YAML constructors directly because we don't save tags into
        YAML, and therefore PyYAML can't deduce object types on reading.
        """
        task = Task()
        task.id = id
        # TODO: validate the object and throw an exception (which?) if it's 
        # missing required fields. Or are all the fields optional?
        # TODO: this certainly can be beautified somehow. Also, it should
        # probably be a constructor of Task that accepts a dictionary
        if "status" in obj:
            # TODO: it can throw an exception. Should we just pass it up to the
            # caller? Then probably all other similar exceptions, too?
            task.status = TaskStatus(obj["status"])
        if "desc" in obj:
            task.set_full_desc(obj["desc"])
        # if "epic" in obj:
        if "comments" in obj:
            # TODO: make sure it's a list
            for c in obj["comments"]:
                if "text" in c and "date" in c:
                    d = c["date"]
                    if type(d) is str:
                        d = datetime.datetime.fromisoformat(d)
                    if type(d) is datetime.datetime:
                        task.comments.append(TaskComment(c["text"], d))
        return task
    